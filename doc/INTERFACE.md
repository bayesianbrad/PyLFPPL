# Interface

_This document describes the interface used as part of PyFOPPL._
 
## Overview

_PyFOPPL_ is a compiler for first order probabilistic programs. It produces a
graphical model, i. e. a graph where the vertices represent either sampled
random values, or observed random values. The edges of the graph indicate
dependencies between the vertices.

When you use _PyFOPPL_, the compiler will provide you with a `model`-object,
which, in turn, provides access to the graph with its vertices. This document
describes the `Model`- as well as the `Vertex`-classes, and how to properly
use them.

NB: _as this a work in progress, the actual objects might include additional
fields and information not described here._


## Model

The model returned by the compiler is an instance of the `Model`-class, found
in [`foppl_model.py`](/foppl/foppl_model.py). It has two primary purposes:
it acts as an interface to access the graph with its vertices, and it can
generate _prior samples_, as well as compute the _log_pdf_ (i. e. the log of
the Probability Density Function).


### Fields and Methods

**`model.draw_graph()`**
  Displays a visual representation of the model, using `networkx` and 
  `matplotlib`.
  
**`model.get_vertices() -> Set[Vertex]`**:  
  Returns the set of all vertices.
  
**`model.get_arcs() -> Set[Tuple(Vertex, Vertex)]`**:
  Returns the set of all directed edges/arcs.
  
**`model.gen_prior_samples() -> Dict[Str, Any]`**:  
  Runs the probabilistic program by drawing random samples for each vertex
  in the graph. Returns a _state_-dictionary (see below).

**`model.gen_pdf(state) -> Float`**:  
  Given a _state_-dictionary as generated by `gen_prior_samples()`, computes
  and returns the log of the pdf. The given argument `state` must contain 
  valid values for each sampled vertex in the graph.
  
**`model.transform_state(state, [samples_only]) -> Dict[Str, Any]`**:  
  Creates a new dictionary with the same entries as the given argument
  `state`. However, wherever possible, the internally used unique names
  (such as `x30002`) are replaced by the names originally used in the 
  user-specified model. In addition, all `data`-entries are removed (they
  serve a supportive role only, anyway).
  
  If the flag `samples_only` is set to `True`, observed values will be
  removed from the dictionary as well.
  
**`model.get_result(state) -> Any`**:
  If the user's model has a return value, this value is computed and
  returned. The argument `state` must be a dictionary as created by
  `model.gen_prior_samples()`.


### State

Both `model.gen_prior_samples()` and `model.gen_pdf(state)` use a 
_state_-object to hold the current state, i. e. the values of variables. In
principle, it corresponds to Python's `locals`-dictionary. However, since it
is preserved across different invocations of the methods, the state can be
preserved, or can be altered in a direct specific way.

For each vertex, the state holds its current value, where the internal name
of the vertex is used as its key (e. g., `x30004`). In addition, the state
might also contain auxiliary variables, in particular the values of conditions
used inside the computation.

You can get a more user-friendly version of the state through the method
`model.transform_state()` (see above).


## Vertices

### Fields and Methods

**`vertex.name`**:  
  A generated, unique name for the vertex. Usually something of the form
  `x30016` or `y30107`, however, this is implementation specific and might
  change without prior notice.
